<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Ïä§ÏúÑÌä∏ Ï∫îÎîî Îß§Ïπò</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (to compile JSX/TS in browser) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;600&display=swap');
      body {
        font-family: 'Fredoka', sans-serif;
        background-color: #fdf2f8;
        overscroll-behavior: none;
        user-select: none;
        -webkit-user-select: none;
      }
      
      /* Animations */
      @keyframes pop {
        0% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.2); opacity: 0.8; }
        100% { transform: scale(0); opacity: 0; }
      }
      .animate-pop {
        animation: pop 0.3s ease-in forwards;
      }
      
      @keyframes drop {
        0% { transform: translateY(-50px); opacity: 0; }
        100% { transform: translateY(0); opacity: 1; }
      }
      .animate-drop {
        animation: drop 0.3s ease-out forwards;
      }

      @keyframes fade-in {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      .animate-fade-in {
        animation: fade-in 0.3s ease-out forwards;
      }

      @keyframes bounce-in {
        0% { transform: scale(0.8); opacity: 0; }
        50% { transform: scale(1.05); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
      }
      .animate-bounce-in {
        animation: bounce-in 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
      }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "lucide-react": "https://esm.sh/lucide-react@^0.561.0",
    "vite": "https://esm.sh/vite@^7.3.0",
    "@vitejs/plugin-react": "https://esm.sh/@vitejs/plugin-react@^5.1.2"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <!-- MAIN GAME SCRIPT -->
    <script type="text/babel" data-presets="react,typescript">
        const { useState, useEffect, useCallback } = React;

        // --- TYPES & CONSTANTS ---
        
        const CandyColor = {
            Red: 'Red',
            Blue: 'Blue',
            Green: 'Green',
            Yellow: 'Yellow',
            Purple: 'Purple',
            Orange: 'Orange',
            Empty: 'Empty'
        };

        const GameState = {
            Idle: 'Idle',
            Swapping: 'Swapping',
            Processing: 'Processing',
            GameOver: 'GameOver',
            LevelComplete: 'LevelComplete'
        };

        const BOARD_SIZE = 8;

        const CANDY_COLORS = {
            [CandyColor.Red]: 'bg-red-500 border-red-600 shadow-red-500/50',
            [CandyColor.Blue]: 'bg-blue-500 border-blue-600 shadow-blue-500/50',
            [CandyColor.Green]: 'bg-green-500 border-green-600 shadow-green-500/50',
            [CandyColor.Yellow]: 'bg-yellow-400 border-yellow-500 shadow-yellow-500/50',
            [CandyColor.Purple]: 'bg-purple-500 border-purple-600 shadow-purple-500/50',
            [CandyColor.Orange]: 'bg-orange-500 border-orange-600 shadow-orange-500/50',
            [CandyColor.Empty]: 'invisible'
        };

        const CANDY_EMOJIS = {
            [CandyColor.Red]: 'üçì',
            [CandyColor.Blue]: 'ü´ê',
            [CandyColor.Green]: 'ü•ù',
            [CandyColor.Yellow]: 'üçã',
            [CandyColor.Purple]: 'üçá',
            [CandyColor.Orange]: 'üçä',
            [CandyColor.Empty]: ''
        };

        const LEVELS = [
            { level: 1, targetScore: 1000, moves: 15, colors: [CandyColor.Red, CandyColor.Blue, CandyColor.Green, CandyColor.Yellow] },
            { level: 2, targetScore: 2500, moves: 20, colors: [CandyColor.Red, CandyColor.Blue, CandyColor.Green, CandyColor.Yellow, CandyColor.Purple] },
            { level: 3, targetScore: 4000, moves: 20, colors: [CandyColor.Red, CandyColor.Blue, CandyColor.Green, CandyColor.Yellow, CandyColor.Purple, CandyColor.Orange] },
            { level: 4, targetScore: 6000, moves: 18, colors: [CandyColor.Red, CandyColor.Blue, CandyColor.Green, CandyColor.Yellow, CandyColor.Purple, CandyColor.Orange] }
        ];

        // --- UTILS ---

        const generateId = () => Math.random().toString(36).substr(2, 9);

        const getRandomCandy = (allowedColors) => {
            const randomColor = allowedColors[Math.floor(Math.random() * allowedColors.length)];
            return {
                id: generateId(),
                color: randomColor,
                isNew: true
            };
        };

        const createBoard = (allowedColors) => {
            const board = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                const row = [];
                for (let c = 0; c < BOARD_SIZE; c++) {
                    let candy = getRandomCandy(allowedColors);
                    // Prevent initial matches
                    while (
                        (c >= 2 && row[c - 1].color === candy.color && row[c - 2].color === candy.color) ||
                        (r >= 2 && board[r - 1][c].color === candy.color && board[r - 2][c].color === candy.color)
                    ) {
                        candy = getRandomCandy(allowedColors);
                    }
                    row.push({ ...candy, isNew: false });
                }
                board.push(row);
            }
            return board;
        };

        const findMatches = (board) => {
            const matchedPositions = new Set();

            // Horizontal
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE - 2; c++) {
                    const color = board[r][c].color;
                    if (color === CandyColor.Empty) continue;
                    if (board[r][c + 1].color === color && board[r][c + 2].color === color) {
                        matchedPositions.add(`${r},${c}`);
                        matchedPositions.add(`${r},${c + 1}`);
                        matchedPositions.add(`${r},${c + 2}`);
                        let k = c + 3;
                        while (k < BOARD_SIZE && board[r][k].color === color) {
                            matchedPositions.add(`${r},${k}`);
                            k++;
                        }
                    }
                }
            }

            // Vertical
            for (let c = 0; c < BOARD_SIZE; c++) {
                for (let r = 0; r < BOARD_SIZE - 2; r++) {
                    const color = board[r][c].color;
                    if (color === CandyColor.Empty) continue;
                    if (board[r + 1][c].color === color && board[r + 2][c].color === color) {
                        matchedPositions.add(`${r},${c}`);
                        matchedPositions.add(`${r + 1},${c}`);
                        matchedPositions.add(`${r + 2},${c}`);
                        let k = r + 3;
                        while (k < BOARD_SIZE && board[k][c].color === color) {
                            matchedPositions.add(`${k},${c}`);
                            k++;
                        }
                    }
                }
            }

            return Array.from(matchedPositions).map(str => {
                const [r, c] = str.split(',').map(Number);
                return { row: r, col: c };
            });
        };

        const isValidSwap = (board, p1, p2) => {
            const tempBoard = board.map(row => row.map(candy => ({ ...candy })));
            const temp = tempBoard[p1.row][p1.col];
            tempBoard[p1.row][p1.col] = tempBoard[p2.row][p2.col];
            tempBoard[p2.row][p2.col] = temp;
            return findMatches(tempBoard).length > 0;
        };

        const areAdjacent = (p1, p2) => {
            const rDiff = Math.abs(p1.row - p2.row);
            const cDiff = Math.abs(p1.col - p2.col);
            return (rDiff === 1 && cDiff === 0) || (rDiff === 0 && cDiff === 1);
        };

        // --- COMPONENTS ---

        const CandyCell = ({ candy, isSelected, onClick }) => {
            if (candy.color === CandyColor.Empty) {
                return <div className="w-full h-full" />;
            }

            const colorClass = CANDY_COLORS[candy.color];
            const emoji = CANDY_EMOJIS[candy.color];

            let className = `
                w-10 h-10 sm:w-12 sm:h-12 md:w-14 md:h-14 
                rounded-xl sm:rounded-2xl 
                flex items-center justify-center 
                text-2xl sm:text-3xl 
                cursor-pointer 
                select-none 
                transition-all duration-300 
                border-b-4 
                shadow-lg
                ${colorClass}
            `;

            if (isSelected) {
                className += ' ring-4 ring-white ring-opacity-80 scale-110 z-10 brightness-110 animate-pulse';
            } else {
                className += ' hover:scale-105 active:scale-95';
            }

            if (candy.isMatched) {
                className += ' animate-pop';
            } else if (candy.isNew) {
                className += ' animate-drop';
            }

            return (
                <div className={className} onClick={onClick}>
                    <span className="drop-shadow-md filter">{emoji}</span>
                </div>
            );
        };

        const GameBoard = ({ board, selectedPos, onCandyClick, isProcessing }) => {
            return (
                <div className="relative p-2 sm:p-4 bg-white/40 backdrop-blur-sm rounded-3xl border-4 border-pink-200 shadow-2xl">
                    <div className="grid grid-cols-8 gap-1 sm:gap-2">
                        {board.map((row, rIndex) =>
                            row.map((candy, cIndex) => {
                                const isSelected = selectedPos?.row === rIndex && selectedPos?.col === cIndex;
                                return (
                                    <div 
                                        key={`${rIndex}-${cIndex}`} 
                                        className="bg-white/20 rounded-lg aspect-square flex items-center justify-center"
                                    >
                                        <CandyCell
                                            candy={candy}
                                            isSelected={isSelected}
                                            onClick={() => !isProcessing && onCandyClick({ row: rIndex, col: cIndex })}
                                        />
                                    </div>
                                );
                            })
                        )}
                    </div>
                </div>
            );
        };

        const ScoreBoard = ({ score, moves, levelConfig }) => {
            const progressPercentage = Math.min((score / levelConfig.targetScore) * 100, 100);
            return (
                <div className="w-full max-w-md mb-6 px-4">
                    <div className="flex justify-between items-end mb-2 text-pink-900 font-bold">
                        <div className="flex flex-col items-center bg-white/80 p-3 rounded-2xl shadow-sm w-24">
                           <span className="text-xs uppercase tracking-wider text-pink-500 mb-1">Î†àÎ≤®</span>
                           <span className="text-2xl">{levelConfig.level}</span>
                        </div>
                        <div className="flex flex-col items-center bg-white/80 p-3 rounded-2xl shadow-sm w-24 mx-2">
                            <span className="text-xs uppercase tracking-wider text-purple-500 mb-1">ÎÇ®ÏùÄ ÌöüÏàò</span>
                            <span className={`text-2xl ${moves < 5 ? 'text-red-500 animate-pulse' : 'text-gray-800'}`}>
                                {moves}
                            </span>
                        </div>
                        <div className="flex flex-col items-center bg-white/80 p-3 rounded-2xl shadow-sm min-w-24 flex-1">
                             <span className="text-xs uppercase tracking-wider text-blue-500 mb-1">Ï†êÏàò</span>
                             <span className="text-2xl">{score}</span>
                        </div>
                    </div>
                    <div className="relative h-6 w-full bg-white rounded-full overflow-hidden border-2 border-white shadow-inner">
                        <div 
                            className="h-full bg-gradient-to-r from-pink-400 via-purple-400 to-indigo-400 transition-all duration-500 ease-out"
                            style={{ width: `${progressPercentage}%` }}
                        />
                        <div className="absolute inset-0 flex items-center justify-center text-xs font-bold text-gray-700 drop-shadow-sm">
                            Î™©Ìëú: {levelConfig.targetScore}
                        </div>
                    </div>
                </div>
            );
        };

        const GameModal = ({ title, message, buttonText, onAction, type }) => {
            return (
                <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4 animate-fade-in">
                    <div className="bg-white rounded-3xl p-8 max-w-sm w-full text-center shadow-2xl transform transition-all animate-bounce-in border-4 border-pink-100">
                        <div className={`mx-auto mb-4 w-20 h-20 rounded-full flex items-center justify-center text-4xl shadow-inner ${type === 'win' ? 'bg-yellow-100' : 'bg-gray-100'}`}>
                            {type === 'win' ? 'üèÜ' : 'üò¢'}
                        </div>
                        <h2 className="text-3xl font-extrabold text-gray-800 mb-2">{title}</h2>
                        <p className="text-gray-600 mb-8 font-medium">{message}</p>
                        <button 
                            onClick={onAction}
                            className="w-full py-4 bg-gradient-to-r from-pink-500 to-purple-600 text-white font-bold rounded-xl shadow-lg hover:shadow-xl hover:scale-105 transition-all active:scale-95 flex items-center justify-center gap-2"
                        >
                            <span className="text-xl">{type === 'win' ? '‚ñ∂Ô∏è' : 'üîÑ'}</span>
                            {buttonText}
                        </button>
                    </div>
                </div>
            )
        }

        // --- APP ---

        const App = () => {
            const [levelIndex, setLevelIndex] = useState(0);
            const [board, setBoard] = useState([]);
            const [score, setScore] = useState(0);
            const [movesLeft, setMovesLeft] = useState(0);
            const [gameState, setGameState] = useState(GameState.Idle);
            const [selectedPos, setSelectedPos] = useState(null);
            
            const currentLevel = LEVELS[levelIndex];

            const initLevel = useCallback((lvlIndex) => {
                const lvl = LEVELS[lvlIndex];
                const newBoard = createBoard(lvl.colors);
                setBoard(newBoard);
                setScore(0);
                setMovesLeft(lvl.moves);
                setGameState(GameState.Idle);
                setSelectedPos(null);
            }, []);

            useEffect(() => {
                initLevel(levelIndex);
            }, [levelIndex, initLevel]);

            const handleCandyClick = (pos) => {
                if (gameState !== GameState.Idle) return;

                if (!selectedPos) {
                    setSelectedPos(pos);
                    return;
                }

                if (selectedPos.row === pos.row && selectedPos.col === pos.col) {
                    setSelectedPos(null);
                    return;
                }

                if (areAdjacent(selectedPos, pos)) {
                    attemptSwap(selectedPos, pos);
                } else {
                    setSelectedPos(pos);
                }
            };

            const attemptSwap = async (p1, p2) => {
                setGameState(GameState.Swapping);
                setSelectedPos(null);

                let newBoard = [...board];
                let temp = newBoard[p1.row][p1.col];
                newBoard[p1.row][p1.col] = newBoard[p2.row][p2.col];
                newBoard[p2.row][p2.col] = temp;
                setBoard([...newBoard]);

                await new Promise(r => setTimeout(r, 300));

                const valid = isValidSwap(board, p1, p2);
                const matches = findMatches(newBoard);

                if (matches.length > 0) {
                    setMovesLeft(prev => prev - 1);
                    processMatches(newBoard);
                } else {
                    newBoard = [...newBoard];
                    temp = newBoard[p1.row][p1.col];
                    newBoard[p1.row][p1.col] = newBoard[p2.row][p2.col];
                    newBoard[p2.row][p2.col] = temp;
                    setBoard([...newBoard]);
                    setGameState(GameState.Idle);
                }
            };

            const processMatches = async (currentBoard) => {
                setGameState(GameState.Processing);
                let activeBoard = [...currentBoard];
                let hasMatches = true;
                let comboMultiplier = 1;

                while (hasMatches) {
                    const matches = findMatches(activeBoard);
                    
                    if (matches.length === 0) {
                        hasMatches = false;
                        break;
                    }

                    const matchesSet = new Set(matches.map(p => `${p.row},${p.col}`));
                    activeBoard = activeBoard.map((row, r) => 
                        row.map((candy, c) => {
                            if (matchesSet.has(`${r},${c}`)) {
                                return { ...candy, isMatched: true };
                            }
                            return candy;
                        })
                    );
                    setBoard([...activeBoard]);
                    
                    const points = matches.length * 10 * comboMultiplier;
                    setScore(prev => prev + points);
                    comboMultiplier++;

                    await new Promise(r => setTimeout(r, 300));

                    activeBoard = activeBoard.map(row => 
                        row.map(candy => 
                            candy.isMatched ? { ...candy, color: CandyColor.Empty, isMatched: false } : candy
                        )
                    );
                    setBoard([...activeBoard]);

                    await new Promise(r => setTimeout(r, 100));
                    activeBoard = applyGravity(activeBoard);
                    setBoard([...activeBoard]);
                    
                    await new Promise(r => setTimeout(r, 300));
                    activeBoard = refillBoard(activeBoard, currentLevel.colors);
                    setBoard([...activeBoard]);
                    
                    await new Promise(r => setTimeout(r, 300));
                }
                setGameState(GameState.Idle);
            };

            const applyGravity = (board) => {
                const newBoard = board.map(row => [...row]);
                for (let c = 0; c < BOARD_SIZE; c++) {
                    let writeRow = BOARD_SIZE - 1;
                    for (let r = BOARD_SIZE - 1; r >= 0; r--) {
                        if (newBoard[r][c].color !== CandyColor.Empty) {
                            newBoard[writeRow][c] = newBoard[r][c];
                            if (writeRow !== r) {
                                newBoard[r][c] = { id: generateId(), color: CandyColor.Empty };
                            }
                            writeRow--;
                        }
                    }
                    while (writeRow >= 0) {
                        newBoard[writeRow][c] = { id: generateId(), color: CandyColor.Empty };
                        writeRow--;
                    }
                }
                return newBoard;
            };

            const refillBoard = (board, allowedColors) => {
                return board.map(row => 
                    row.map(candy => {
                        if (candy.color === CandyColor.Empty) {
                            return getRandomCandy(allowedColors);
                        }
                        return candy;
                    })
                );
            };

            useEffect(() => {
                if (gameState === GameState.Processing || gameState === GameState.Swapping) return;

                if (score >= currentLevel.targetScore) {
                    setGameState(GameState.LevelComplete);
                } else if (movesLeft <= 0) {
                    setGameState(GameState.GameOver);
                }
            }, [score, movesLeft, currentLevel.targetScore, gameState]);

            const handleNextLevel = () => {
                if (levelIndex < LEVELS.length - 1) {
                    setLevelIndex(prev => prev + 1);
                } else {
                    alert("Î™®Îì† Î†àÎ≤®ÏùÑ ÏôÑÎ£åÌñàÏäµÎãàÎã§! Î†àÎ≤® 1Î∂ÄÌÑ∞ Îã§Ïãú ÏãúÏûëÌï©ÎãàÎã§.");
                    setLevelIndex(0);
                }
            };

            const handleRetry = () => {
                initLevel(levelIndex);
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-indigo-100 via-purple-100 to-pink-100 flex flex-col items-center justify-center p-4">
                    <h1 className="text-4xl sm:text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-violet-600 mb-6 drop-shadow-sm tracking-tight text-center">
                        Ïä§ÏúÑÌä∏ Ï∫îÎîî Îß§Ïπò
                    </h1>

                    <ScoreBoard score={score} moves={movesLeft} levelConfig={currentLevel} />

                    <GameBoard 
                        board={board} 
                        selectedPos={selectedPos} 
                        onCandyClick={handleCandyClick}
                        isProcessing={gameState !== GameState.Idle}
                    />

                    {gameState === GameState.LevelComplete && (
                        <GameModal 
                            title="Î†àÎ≤® ÌÅ¥Î¶¨Ïñ¥!" 
                            message={`Î™©Ìëú Ï†êÏàò ${currentLevel.targetScore}Ï†êÏùÑ Îã¨ÏÑ±ÌñàÏäµÎãàÎã§!`}
                            buttonText="Îã§Ïùå Î†àÎ≤®"
                            onAction={handleNextLevel}
                            type="win"
                        />
                    )}

                    {gameState === GameState.GameOver && (
                        <GameModal 
                            title="Ïù¥Îèô ÌöüÏàò Ï¥àÍ≥º!" 
                            message="ÏïÑÏâΩÎÑ§Ïöî, Îã§Ïãú ÎèÑÏ†ÑÌï¥Î≥¥ÏÑ∏Ïöî!"
                            buttonText="Îã§Ïãú ÎèÑÏ†Ñ"
                            onAction={handleRetry}
                            type="lose"
                        />
                    )}
                    
                    <div className="mt-8 text-gray-400 text-sm">
                        Ï∫îÎîî 3Í∞ú Ïù¥ÏÉÅÏùÑ Ïó∞Í≤∞ÌïòÏó¨ Ï†êÏàòÎ•º ÌöçÎìùÌïòÏÑ∏Ïöî!
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>